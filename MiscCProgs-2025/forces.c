#include <math.h>
#include <stdio.h>

const float G = 0.01;
const int nParticles = 10;
struct position {
	float x;
	float y;
};

const struct position  zero_pos = {0.0, 0.0};

void read_initial_positions(struct position particles[]){
	printf("Give x and y coords of the initial particle positions\n");
	for(int i=0;i<nParticles;i++)
		scanf("%f %f",&particles[i].x, &particles[i].y);
}
void read_initial_velocities(struct position velocities[]){
	for(int i=0;i<nParticles;i++)
		velocities[i]=zero_pos;
}
void show_final_positions(struct position particles[]){
	for(int i=0;i<nParticles;i++)
		printf("%f %f\n",particles[i].x, particles[i].y);
}
void read_nsteps(int *nsteps){
	printf("Howmany steps ?");
	scanf("%d",nsteps);
}

struct position minus(struct position p1, struct position p2){
	struct position new;
	new.x=p1.x-p2.x;
	new.y=p1.y-p2.y;
	return new;
}
struct position sum(struct position p1, struct position p2){
	struct position new;
	new.x=p1.x+p2.x;
	new.y=p1.y+p2.y;
	return new;
}

struct position find_acc(struct position diffvector){
	// We take actual displacement is G/R^2 of unit diffvector. Here is a small multiplicative factor
	float R = sqrt(diffvector.x*diffvector.x+diffvector.y*diffvector.y);
	struct position acc_vector;
	acc_vector.x=diffvector.x/(R*R) * G;
	acc_vector.y=diffvector.y/(R*R) * G;
	return acc_vector;
}
struct position acc_ij(struct position particles[],int i, int j){
	struct position pos_diffvector=minus(particles[j],particles[i]);
	struct position acc_vector=find_acc(pos_diffvector);       //found the dir and magnitude of accelleration
	return acc_vector;
}

void new_acc(struct position particles[],int i, struct position nextacc[]){
	nextacc[i]=zero_pos; 
	for(int j=0;j<nParticles;j++)
		if(j!=i)
			nextacc[i]=sum(nextacc[i],acc_ij(particles,i,j));

}

void new_vel(struct position velocities[], struct position nextacc[], int i){
	// v_x = u_x + a_x     (assuming v = u + at and t=1 and in the x directio; ... similarly in the y direction)
	velocities[i].x=velocities[i].x+nextacc[i].x;
	velocities[i].y=velocities[i].y+nextacc[i].y;
}

struct position new_pos(struct position particles[], struct position velocities[], struct position nextacc[], int i){
	// delta_x = u_x  + 0.5 * a_x        i.e. s=ut + 1/2 at^2  - whree t is 1, and dir is x
	// similarly delta_y
	struct position delta;
	delta.x=velocities[i].x + 0.5 * nextacc[i].x;
	delta.y=velocities[i].y + 0.5 * nextacc[i].y;
	return(sum(particles[i],delta));
}

int main(){

	struct position particles[nParticles];
	struct position velocities[nParticles];
	struct position nextacc[nParticles];
	struct position nextpos[nParticles];
	read_initial_positions(particles);
	read_initial_velocities(velocities);
	int nsteps;
	read_nsteps(&nsteps);
	for(int s=0;s<nsteps;s++){
		for(int i=0;i<nParticles;i++)
			new_acc(particles,i,nextacc);
		for(int i=0;i<nParticles;i++)
			nextpos[i]=new_pos(particles,velocities,nextacc,i);
		for(int i=0;i<nParticles;i++)
			particles[i]=nextpos[i];
		for(int i=0;i<nParticles;i++)
			new_vel(velocities,nextacc,i);
			
	}
	show_final_positions(particles);
}
/*

   Graded programming excercies
   1.
   Assume a particle moves linearly on the x axis
   Let its initial position p, velocity u and initial accelleration a be given.
   Find its new position and new velocity after 1 unit of time.
   2. 
   Assume the accelleration is generated by the attraction due to another particle is given by: 
      a= G / R^2  where R is the difference of their positions( i.e., R = p_second - p) and G is the constant 0.01
      and the accelleration is in the direction of the new particle,
   Now find its new position and new velocity after 1 unit of time. The difference is that now you need to compute a.
   3. 
   Assume as in part 2 above, and additionally the position and velocity of the second particle is given; and assume
   symmetrically that the original particle (lets call it particle 1) exerts a similar force on particle 2, then
   find the new position and new velocity of particles 1 and 2 after 1 unit of time.
   Find the positions after each unit of time for 10 units of time.
 
   -------------- using a small array of [x,y] or a structure now --------------
   4. As in 3. above, but now assume particles are in a 2D plane. thus position, velocity and accelleration are now
   having both x and y components.
   Find the new position and new velocity of particles 1 and 2 after 1 unit of time. Similarly find positions after 10 
   units of time.

   ------------- using nx2 arrays or arrays of structures now ----------------
   5. As in 4. However now we have n particles.  Now particle 1's net accelleration is the sum of the accellerations caused 
   by the n-1 other particles. This acceleration can now be used as in 4, to find the new position and velocity of particle 1.
   We wish to find the new position and new velocity of the n particles after 1 unit of time. Similarly positions after
   10 units of time.

 */
